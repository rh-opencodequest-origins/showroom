:imagesdir: ../../assets/images

= Developer Activity: Welcome onboard in "Premi√®re Classe" - Drink your own champagne !

IMPORTANT: Please make sure you are logged in as a Developer with `{dev-username}` / `{common_password}` as you were guided to in the previous step.

include::../style.adoc[]
++++
<div class="developer">
++++

Once in the hero-service component home page, you can launch the Dev Spaces opening by clicking the link OpenShift Dev Spaces (VS Code)

image:m4/hero-home-page-rhdh.png[] 

You may be asked to authenticate again. Please, proceed. 
You should see the following page while the Dev Spaces is starting up:

image:m4/dev-spaces-starting-up.png[]


## The Hero Service



The Super Heroes microservice stores super-heroes, with their names, powers, and so on.
We need to expose a REST API allowing CRUD operations on _super heroes_.
This microservice is a *classical* microservice.

It uses HTTP to expose a REST API, and it internally stores data into a database.

This service will be used by the *fight* microservice.



## Import the code base 

Our workspace directory looks empty. In order to start the project quickly, the hero code base is located in an external gitlab repository. Let's import it !


### Open the terminal to import the zip file

* Click on the "Burger icon" on the upper left side
* Click on File > Terminal > Open a new terminal

image:m4/open-terminal.png[]

* Run the following command 

[,bash,subs=attributes]

====
wget https://gitlab-gitlab.{openshift_cluster_ingress_domain}/rh-opencodequest-origins/fullcodebase/raw/refs/heads/main/hero-service.zip -O hero-service.zip && unzip hero-service.zip && rm hero-service.zip
====


Confirm you have this directory : 

image:m4/hero-directory.png[]



## Directory Structure

Once you bootstrap the project, you get the following directory structure with a few Java classes and other artifacts:

image:m4/hero-directory-structure.svg[]



It generates the following in the `hero-service` folder:

* the Maven structure with a `pom.xml`
* an `io.quarkus.workshop.hero.HeroResource` resource exposed on `/api/heroes`
* an associated unit test `HeroResourceTest`
* the landing page `index.html` that is accessible after starting the application
* the `application.properties` configuration file

#Look at the `pom.xml`# 
You will find here the import of the Quarkus BOM (_bill of materials_), allowing you to omit the version on the different Quarkus dependencies.
In addition, you can see the `quarkus-maven-plugin`, responsible for the packaging of the application and also providing the development mode support.

Regarding the dependencies section, you can see the extension allowing the development of REST applications.


## The JAX-RS Resource

During the project creation, the *hero-service > src > main > java > io > quarkus > workshop > hero > HeroResource.java* file has been created with the following content. 

### Uncomment the file content

Open it and remove the first of the file:

image:m4/start-comment-line.png[]

and the last one:

image:m4/end-comment-line.png[]


This file has a set of simple REST endpoints. For instance, returning "hello" to HTTP GET requests to `/api/heroes`.


```java


    @GET
    @Path("/hello")
    public String hello() {
        return "Hello from Quarkus REST";
    }

``` 
## Running the Application

We are now ready to run our application.

You can use either the `quarkus` cli or `Apache Maven` command-line interface in a Terminal.

#Open a Terminal by clicking on the hamburger menu (three horizontal lines) located in the upper-left corner of the screen#

#Navigate to Terminal and select New Terminal from the dropdown menu#

#Then, run one of the following commands :#

`./mvnw quarkus:dev`

or 

`quarkus dev`

```shell
$  quarkus dev
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------< com.redhat.workshop:hero-service >------------------
[INFO] Building hero-service 1.0-SNAPSHOT
[INFO]   from pom.xml
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- quarkus:3.13.2:dev (default-cli) @ hero-service ---
[INFO] Invoking resources:3.3.1:resources (default-resources) @ hero-service
[INFO] Copying 2 resources from src/main/resources to target/classes
[INFO] Invoking quarkus:3.13.2:generate-code (default) @ hero-service
[INFO] Invoking compiler:3.13.0:compile (default-compile) @ hero-service
[INFO] Nothing to compile - all classes are up to date.
[INFO] Invoking resources:3.3.1:testResources (default-testResources) @ hero-service
[INFO] skip non existing resourceDirectory /projects/hero/src/test/resources
[INFO] Invoking quarkus:3.13.2:generate-code-tests (default) @ hero-service
[INFO] Invoking compiler:3.13.0:testCompile (default-testCompile) @ hero-service
[INFO] Nothing to compile - all classes are up to date.

----------------------------
--- Help improve Quarkus ---
----------------------------
* Learn more: https://quarkus.io/usage/
* Do you agree to contribute anonymous build time data to the Quarkus community? (y/n and enter) 
[info] [Quarkus build analytics] Didn't receive the user's answer after 10 seconds. The question will be asked again next time.

Listening for transport dt_socket at address: 5005
2024-08-28 11:39:46,023 INFO  [io.qua.dat.dep.dev.DevServicesDatasourceProcessor] (build-21) Dev Services for default datasource (postgresql) started - container ID is b64fe935733f
2024-08-28 11:39:46,026 INFO  [io.qua.hib.orm.dep.dev.HibernateOrmDevServicesProcessor] (build-34) Setting quarkus.hibernate-orm.database.generation=drop-and-create to initialize Dev Services managed database
__  ____  __  _____   ___  __ ____  ______ 
 --/ __ \/ / / / _ | / _ \/ //_/ / / / __/ 
 -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\ \   
--\___\_\____/_/ |_/_/|_/_/|_|\____/___/   
2024-08-28 11:39:46,603 WARN  [io.qua.config] (Quarkus Main Thread) Unrecognized configuration key "quarkus.smallrye-openapi.store-schema-directory" was provided; it will be ignored; verify that the dependency extension for this configuration is set or that you did not make a typo
2024-08-28 11:39:48,103 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) SQL Warning Code: 0, SQLState: 00000
2024-08-28 11:39:48,105 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) table "myentity" does not exist, skipping
2024-08-28 11:39:48,106 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) SQL Warning Code: 0, SQLState: 00000
2024-08-28 11:39:48,106 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) sequence "myentity_seq" does not exist, skipping
2024-08-28 11:39:48,316 INFO  [io.quarkus] (Quarkus Main Thread) hero-service 1.0-SNAPSHOT on JVM (powered by Quarkus 3.13.2) started in 7.445s. Listening on: http://0.0.0.0:8080
2024-08-28 11:39:48,317 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.
2024-08-28 11:39:48,317 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [agroal, cdi, hibernate-orm, hibernate-orm-panache, hibernate-validator, jdbc-postgresql, micrometer, narayana-jta, rest, rest-jackson, smallrye-context-propagation, smallrye-health, vertx]

--
Tests paused
Press [e] to edit command line args (currently ''), [r] to resume testing, [o] Toggle test output, [:] for the terminal, [h] for more options>
```

At some point, a pop up asking for opening the Quarkus dev will be shown:

image:m4/open-quarkus-dev-in-new-tab.png[]

#Click on the `Open in New Tab` button#

You can now check that the endpoint returns `Hello from Quarkus REST` as expected.

#Open a new Terminal and run the following command#

```shell
curl http://localhost:8080/api/heroes/hello
```

## Development Mode

`mvn quarkus:dev` or `quarkus dev` runs Quarkus in development mode.
This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and invoke a REST endpoint (i.e. cUrl command or refresh your browser), these changes will automatically take effect.
If there are any issues with compilation an error page will let you know.

The development mode also allows debugging and listens for a debugger on port 5005.

### Dev UI

Quarkus ships with a Developer UI, which is available in dev mode at /q/dev-ui path by default.
It will show you something like this:

image:m4/dev-ui.png[]

It allows you to:

* quickly visualize all the extensions currently loaded
* view extension statuses and go directly to extension documentation
* view and change Configuration
* manage and visualize Continuous Testing
* view Dev Services information
* view the Build information
* view and stream various logs

Each extension used in the application will be listed

#Open the Developer Console by navigating to the $HERO_URL/q/dev-ui# 

## Testing the Application

So far so good, but wouldn't it be better with a few tests, just in case?

In the generated `pom.xml` file, you can see 2 test dependencies:

```xml
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-junit5</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>io.rest-assured</groupId>
    <artifactId>rest-assured</artifactId>
    <scope>test</scope>
</dependency>

```

### Uncomment the HeroResourceTest.java

The generated project contains a simple test.
The file content to uncomment is located here : *hero-service > src > test > java > io > quarkus > workshop > hero > HeroResourceTest.java*

Open it and remove the first of the file:

image:m4/start-comment-line.png[]

and the last one:

image:m4/end-comment-line.png[]


By using the `QuarkusTest` runner, the `HeroResourceTest` class instructs JUnit to start the application before the tests.
Then, the `testHelloEndpoint` method checks the HTTP response status code and content.

You can running the tests with `./mvnw test` in a new Terminal.

### Continuous testing

Quarkus supports continuous testing, where tests run immediately after code changes have been saved. 
This allows you to get instant feedback on your code changes.

#When you start Quarkus in dev mode, down the bottom of the screen you should see the following#:

```shell
Tests paused, press [r] to resume, [h] for more options>
```
#Press `r and the tests will start running.#
You should see the status change down the bottom of the screen as they are running, and it should finish with

```shell
All 1 test is passing (0 skipped), 1 test was run in 8053ms. Tests completed at 12:11:25.
Press [e] to edit command line args (currently ''), [r] to re-run, [o] Toggle test output, [:] for the terminal, [h] for more options>
```


## Database dependencies

This microservice:

* interacts with a PostGreSQL database - so it needs a driver
* uses Hibernate with Panache - so need the dependency on it
* validates payloads and entities - so need a validator
* consumes and produces JSON - so we need a mapper

Hibernate ORM is the de-facto JPA implementation and offers you the full breadth of an Object Relational Mapper.
It makes complex mappings possible, but it does not make simple and common mappings trivial.
[Hibernate ORM with Panache](https://gitlab-gitlab.{openshift_cluster_ingress_domain}/quarkusio/quarkus/tree/master/extensions/panache) focuses on making your entities trivial and fun to write in Quarkus.

Because JPA and Bean Validation work well together, we will use Bean Validation to constrain our business model.

All the needed dependencies to access the database are already in the `pom.xml` file. 


```xml
  <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-jdbc-postgresql</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-hibernate-orm-panache</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-hibernate-validator</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-rest-jackson</artifactId>
        </dependency>
```


## Hero Entity

At this point we need an Entity class.
There is already a `Hero.java` file under *src > main > java > io > quarkus > workshop > hero.java* so you don't need to create it.
However this file is empty.
To define a Panache entity, simply extend `PanacheEntity`, annotate it with `@Entity` and add your columns as public fields (no need to have getters and setters).

### Uncomment the Hero.java file 

It is located under *src > main > java > io > quarkus > workshop > hero.java*

Open it and remove the first of the file:

image:m4/start-comment-line.png[]

and the last one:

image:m4/end-comment-line.png[]


Notice that you can put all your JPA column annotations and Bean Validation constraint annotations on the public fields.

For our workshop we need returning a random hero.


```java
 public static Hero findRandom() {
        Random random = new Random();
        var count = count();
        var index = random.nextInt((int) count);
        return findAll().page(index, 1).firstResult();
    }
```




## Configuring Hibernate

As Quarkus supports the automatic provisioning of unconfigured services in development and test mode, we don't need at the moment to configure anything regarding the database access. 
Quarkus will automatically start a Postgresql service and wire up your application to use this service. 

Quarkus development mode is great for apps that combine front-end, services, and database access. By using quarkus.hibernate-orm.database.generation=drop-and-create with import.sql, any changes to your entities automatically recreate the database schema and repopulate data. This setup works perfectly with Quarkus live reload, instantly applying changes without restarting the app.


### Adding Data

#To load some data when Hibernate ORM starts, run the following command on a Terminal#

```shell
curl https://raw.githubusercontent.com/cescoffier/quarkus-openshift-workshop/03d5a943c0948bc53c598b6ee78a71e50ef77cee/hero-service/src/main/resources/import.sql -fL -o src/main/resources/import.sql
```

It will download the specified file and copy the content in your `/src/resources/import.sql` file.
Now, you have around 500 heroes that will be loaded in the database.




++++
</div>
++++