:imagesdir: ../../assets/images

++++
<div class="developer">
++++


= Developer Activity: Welcome on board in "Premi√®re Classe" - Drink your own champagne!

IMPORTANT: Please make sure you are logged in as a Developer with *`{dev-username}` / `{common_password}`* as you were guided to in the previous step. We advise you to use a *private/incognito window* to log out properly!  

include::../style.adoc[]

## The home page dashboard

On the development home page, all tools needed are represented by different tabs such as :

* Topology
* Issues
* CI 
* Image Registry
* Docs etc..

It maps with the following integrations performed backstage ;)


image:m3/template-components.png[]

++++
</div>
++++


It's the entry point for everything !! 

Our first mission is to add a new tab to monitor changes performed by our GitOps engine. 

NOTE: We will explore tabs through the lab guide. But don't be shy and feel free to open the tabs!

## Customize your development project dashboard 

Since the beginning of the workshop, we have leveraged GitOps mechanisms thanks to ArgoCD. As a developer, it would be nice to get an overview of the objects we manage through our development environment without leaving our new hometown. The Internal Developer Portal !
To do so, we will enable the ArgoCD view in our dashboard, freshly instantiated.
The *CD* shortcut in the dashboard will display this view :

image:m4/argocd-view.png[]

### You are the owner of your dashboard

Dashboard definition is located in the git repo instantiated to host your code base. In our GitLab repository. It's a way to bring tooling and coding consistently. 
Dashboard UI components are defined in a file named *catalog-info.yaml*.
Let's open the IDE cloud, *Openshift Devspaces*, and jump into the dashboard edit!

image:m4/hero-home-page-rhdh.png[] 

You may be asked to authenticate again. Please, proceed. 
You should see the following page while the Dev Spaces is starting up:

image:m4/dev-spaces-starting-up.png[]

Open the IDE cloud here : 

image:m4/catalog-info-location.png[]

Please open the *catalog-info.yaml* and uncomment the following annotation.

* Remove the  *#* 

image:m4/uncomment-catalog-info.png[]

* It must look like this. Be sure to respect the right YAML identation 

image:m4/uncommented-catalog-info.png[]



NOTE: To simplify the development flow, we'll commit later with the changes done on our code base. The dashboard will be updated automatically.

## The Villain Microservice


The Villain REST Endpoint uses the Spring compatibility layer provided by Quarkus.
While users are encouraged to use Quarkus extensions, this compatibility layer is provided to make developing new applications with Quarkus a natural getting-started experience.


### Import the code base 

Our workspace directory looks empty. In order to start the project quickly, the villain code base is located in an external GitLab repository. Let's import it !

### Open the terminal to import the zip file

* Click on the "Burger icon" on the upper left side
* Click on File > Terminal > Open a new terminal

image:m4/open-terminal.png[]

* Run the following command 

[,bash,subs=attributes]

====

wget https://gitlab-gitlab.{openshift_cluster_ingress_domain}/pe{team-id}/fullcodebase/-/raw/main/villain-service.zip -O villain-service.zip && unzip -o villain-service.zip && rm villain-service.zip

====


Confirm you have this directory : 

image:m4/villain-directory.png[]


### Architecture

At the heart of the Super Hero application come also  _villains_.

We need to expose a REST API allowing CRUD operations on _super heroes_.
This microservice is also a *classical* microservice.
It uses HTTP to expose a REST API, and it internally stores data in a database.

This service will be used by the *fight* microservice.

#The codebase is provided but you will have to bring some guided modifications ;) !#

### Directory Structure

Once you bootstrap the project, you get the following directory structure with a few Java classes and other artifacts:

image:m4/villain-directory-structure.svg[]

You get the following in the `villain-service` folder:

* the Maven structure with a `pom.xml`
* an `io.quarkus.workshop.villain.VillainController` controller exposed on `/api/heroes`
* an associated unit test `VillainControllerTest`
* example `Dockerfile` files for both native and JVM modes in `src/main/docker`
* the `application.properties` configuration file

#Look at the `pom.xml`.#

The `pom.xml` is basically the same as for heroes, apart from the fact that it contains a few more dependencies: `quarkus-spring-web` and `quarkus-spring-data`.

The Quarkus Spring compatibility extensions map Spring APIs to APIs in existing extensions that have already been optimized for fast startup, reduced memory utilization, and native compilation, like RestEasy and CDI.

#Be aware that Quarkus Spring compatibility extensions do not utilize the Spring application context.#
For this reason, attempting to utilize additional Spring libraries will likely not work.

### The Controller

We get a rest controller, the `VillainController.java`.
This class is commented. Please uncomment it before exploring it.
The file is located in *villain-service > src > main > java > io > quarkus > workshop > villain VillainController.java*

Open it and remove the first part of the file:

image:m4/start-comment-line.png[]

And the last one:

image:m4/end-comment-line.png[]



This controller exposes CRUD operations to "villains" and leverages Spring Web and Spring Data JPA annotations for handling HTTP requests and transactions:

1. **@RestController**: Marks the class as a RESTful controller where every method returns a JSON response instead of a view. 

2. **@RequestMapping**: Specifies the base URL path (`/api/villains`) for all the endpoints within this controller. It replaces the standard JAX-RS `@Path`

3. **@GetMapping, @PostMapping, @PutMapping, @DeleteMapping**: These annotations define HTTP methods (GET, POST, PUT, DELETE) to map specific endpoints to CRUD operations.

Not Spring-specific annotations, but used like in the hero-service:

1. **@Transactional**: Ensures that the methods annotated with it are executed within a transaction context, which automatically commits or rolls back the transaction.

5. **@Valid**: Validates the input entity (`Villain`) based on the constraints defined on its fields.

6. **@Context**: Injects `UriInfo`, which provides contextual information about the current URI to help in creating new URIs for created resources.

7. **@RunOnVirtualThread**: Runs the controller on a virtual thread for better concurrency management. This is specific to the SmallRye library.


## Accessing Database

As everything is in place, the `import.sql` file already contains all SQL statements to populate the villain database.

### The Villain repository

As we are following a Spring Data programming model with JPA,we need to extend the JPA-specific Repository interface, JpaRepository. 
This will enable Quarkus to find this interface and automatically create an implementation for it.

#Uncomment VillainRepository as you did previously#

The file is located in *villain-service > src > main > java > io > quarkus > workshop > villain >VillainRepository.java* 


Open it and remove the first of the file:

image:m4/start-comment-line.png[]

And the last one:

image:m4/end-comment-line.png[]

By extending the interface, we get the most relevant CRUD methods automatically. 

You can check the `VillainRepository.java` code. It also contains a more specific method to retrieve a villain randomly from the database:

```java
    default Villain findRandom() {
        var count = count();
        var index = (int) (Math.random() * count);
        return findAll().get(index);
    }
```

### The Villain entity

Finally, we have an entity class representing the villains.

#Uncomment Villain Entity as you did previously#

The file is located in *villain-service > src > main > java > io > quarkus > workshop > villain > Villain.java*  

Open it and remove the first of the file:

image:m4/start-comment-line.png[]

And the last one:

image:m4/end-comment-line.png[]


## Tests

As in the case of the heroes, the tests could not be missing here. 
A test class is provided and contains the basic tests to ensure that the villain microservice works correctly.

You can check that everything works fine by starting the application in development mode.

#Run one of the following commands:#

`./mvnw quarkus:dev`

or

`quarkus dev`

Note that the tests have been successfully run. 

#Also, you can curl the villains endpoint and you should get lots of villains#

```shell
curl http://localhost:8080/api/villains
```

Now, we are ready to value our code with the trusted pipelines!

