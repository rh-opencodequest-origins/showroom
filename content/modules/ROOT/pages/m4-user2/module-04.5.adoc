:imagesdir: ../../assets/images

= Developer Activity: Welcome onboard in "Premi√®re Classe" - Drink your own champagne

IMPORTANT: Please make sure you are logged in as a Developer with `{dev-username}` / `{common_password}` as you were guided to in the previous step.

include::../style.adoc[]
++++
<div class="developer">
++++

== Creating the Villain Microservice


The Villain REST Endpoint uses the Spring compatibility layer provided by Quarkus.
While users are encouraged to use Quarkus extensions, this compatibility layer is provided to make developing new applications with Quarkus a natural getting started experience.



* If everything went well, you should see the following successful page. 


image:m4/villain-success-rhdh.png[]

#Click on the `Open Component in Catalog`#


== Bootstrapping the Villain Rest Endpoint


* #Once in the villain-service component home page, you can launch the Dev Spaces opening by clicking the link OpenShift Dev Spaces (VS Code)#

image:m4/villain-home-page-rhdh.png[]



== Import the code base 

Our workspace directory looks empty. In order to start the project quickly, the villain code base is located in an external gitlab repository. Let's import it !

=== Open the terminal to import the zip file

* Click on the "Burger icon" on the upper left side
* Click on File > Terminal > Open a new terminal

image:m4/open-terminal.png[]

* Run the following command 

```bash
wget https://gitlab-gitlab.{openshift_cluster_ingress_domain}/rh-opencodequest-origins/fullcodebase/raw/refs/heads/main/villain-service.zip -O villain-service.zip && unzip villain-service.zip && rm villain-service.zip
```

Confirm you have this directory : 

image:m4/villain-directory.png[]


== The Villain Service

At the heart of the Super Hero application come also  _villains_.

We need to expose a REST API allowing CRUD operations on _super heroes_.
This microservice is also a *classical* microservice.
It uses HTTP to expose a REST API, and it internally stores data into a database.

This service will be used by the *fight* microservice.

#The codebase is provided but you will have to bring some guided modifications ;) !#

=== Directory Structure

Once you bootstrap the project, you get the following directory structure with a few Java classes and other artifacts:

image:m4/villain-directory-structure.svg[]

You get the following in the `villain-service` folder:

* the Maven structure with a `pom.xml`
* an `io.quarkus.workshop.villain.VillainController` controller exposed on `/api/heroes`
* an associated unit test `VillainControllerTest`
* example `Dockerfile` files for both native and jvm modes in `src/main/docker`
* the `application.properties` configuration file

#Look at the `pom.xml`.#

The `pom.xml` is basically the same than for heroes apart that it contains a few more dependencies: `quarkus-spring-web` and `quarkus-spring-data`.

The Quarkus Spring compatibility extensions map Spring APIs to APIs in existing extensions that have already been optimized for fast startup, reduced memory utilization and native compilation, like RestEasy and CDI.

#Be aware that Quarkus Spring compatibility extensions do not utilize the Spring application context.#
For this reason, attempting to utilize additional Spring libraries will likely not work.

== The Controller

We get a rest controller, the `VillainController.java`.
This class is commented. Please uncomment it before explore it.
The file is located in *villain-service > src > main > java > io > quarkus > workshop > villain VillainController.java*

Open it and remove the first of the file:

image:m4/start-comment-line.png[]

and the last one:

image:m4/end-comment-line.png[]



This controller exposes CRUD operations to "villains" and leverages Spring Web and Spring Data JPA annotations for handling HTTP requests and transactions:

1. **@RestController**: Marks the class as a RESTful controller where every method returns a JSON response instead of a view. 

2. **@RequestMapping**: Specifies the base URL path (`/api/villains`) for all the endpoints within this controller. It replaces the standard JAX-RS `@Path`

3. **@GetMapping, @PostMapping, @PutMapping, @DeleteMapping**: These annotations define HTTP methods (GET, POST, PUT, DELETE) to map specific endpoints to CRUD operations.

Not Spring specific annotations but used like in the hero-service:

1. **@Transactional**: Ensures that the methods annotated with it are executed within a transaction context, which automatically commits or rolls back the transaction.

5. **@Valid**: Validates the input entity (`Villain`) based on the constraints defined on its fields.

6. **@Context**: Injects `UriInfo`, which provides contextual information about the current URI to help in creating new URIs for created resources.

7. **@RunOnVirtualThread**: Runs the controller on a virtual thread for better concurrency management. This is specific to the SmallRye library.


== Accessing Database

As everything is in place the `import.sql` file contains already all SQL statements to populate the villain database.

=== The Villain repository

As we are following a Spring Data programming model with JPA,we need to extend the JPA specific Repository interface, JpaRepository. 
This will enable Quarkus to find this interface and automatically create an implementation for it.

#Uncomment VillainRepository as you did previously#

The file is located in *villain-service > src > main > java > io > quarkus > workshop > villain >VillainRepository.java* 


Open it and remove the first of the file:

image:m4/start-comment-line.png[]

and the last one:

image:m4/end-comment-line.png[]

By extending the interface, we get the most relevant CRUD methods automatically. 

You can check the `VillainRepository.java` code. It also contains a more specific method to retrieve a villain randomly from database:

```java
    default Villain findRandom() {
        var count = count();
        var index = (int) (Math.random() * count);
        return findAll().get(index);
    }
```

=== The Villain entity

Finally we have an entity class representing the villains.

#Uncomment Villain Entity as you did previously#

The file is located in *villain-service > src > main > java > io > quarkus > workshop > villain > Villain.java*  

Open it and remove the first of the file:

image:m4/start-comment-line.png[]

and the last one:

image:m4/end-comment-line.png[]


== Tests

As in the case of the heroes, the tests could not be missing here. 
A test class is provided and contains the basic tests to ensure that the villain microservice works correctly.

You can check that everything works fine by starting the application in development mode.

#Run one of the following commands:#

`./mvnw quarkus:dev`

or

`quarkus dev`

Note that the tests have been successful run. 

#Also, you can curl the villains endopoint and you should get lots of villains#

```shell
curl http://localhost:8080/api/villains
```

Now, we are ready to value our code with the trusted pipelines !

++++
</div>
++++